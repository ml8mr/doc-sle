<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
 type="text/xml"
 title="Profiling step"?>

<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>

<article xml:id="art.pci-dss" xml:lang="en" version="5.0"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Payment Card Industry Data Security Standard (PCI-DSS) Guide</title>
 <info>
  <productnumber>&productnumber;</productnumber><productname>&productname;</productname><date>
  <?dbtimestamp format="B d, Y" ?></date>
 <abstract>
   <para>
    <remark>
     FIXME - sknorr, 2017-11-30
    </remark>
   </para>
 </abstract>
 </info>
 <sect1>
  <title>Introduction</title>
  <para>
   Any company that handles card payments from customers will need to
   protect their data and keep it as safe and secure as possible. This is on
   a mutual basis to protect customers and the business itself. For this it
   is important to evaluate all aspects of the business environment that are
   somehow involved in processing cardholder data. The Data helps to cover
   all areas that are somehow part of the process and to implement security
   relevant actions to keep the data, and the environment it relies on, save.
  </para>
  <para>
   An essential part is the combination of actions. It is not only necessary
   to configure a service secure, but it is also important that the
   configuration is not changed afterwards. If something got changed it is
   important to keep track on who changed what at which point in time.
  </para>
  <para>
   This SUSE security guide should give you a basic understanding of how
   SUSE Linux Enterprise can be configured to comply with the PCI Data
   Security Standard.
  </para>
  <para>
   Again, it is most important to understand that protecting the systems does
   not end by the configuration. It is the whole environment and people
   involved that needs to be taken into account.
  </para>
 </sect1>
 <sect1>
  <title>What is PCI DSS?</title>
  <para>
   The Payment Card Industry Data Security Standard (PCI DSS) is a set of
   requirements to guide a merchant to protect credit cardholder data. The
   standard covers 6 main categories with currently 12 requirement topics
   how to implement, protect, maintain and monitor systems that are involved
   with credit cardholder data processing.
  </para>
  <para>
   PCI DSS was created and is maintained by the PCI Security Standards
   Council (SSC) that was founded by all five major credit card brands Visa,
   MasterCard, American Express, Discover, and JCB. In December 2004 PCI DSS
   1.0 was released to address the growing thread of online credit card
   fraud. Currently version 3.2 is available since April 2016.
  </para>
  <!-- FIXME: The requirements need to have consistent numbering instead of
  starting from 1 each time. -->
  <variablelist>
   <varlistentry>
    <term>Build and Maintain a Secure Network and Systems</term>
    <listitem>
     <orderedlist>
      <listitem>
       <para>
        Install and maintain a firewall configuration to protect cardholder
        data
       </para>
      </listitem>
      <listitem>
       <para>
        Do not use vendor-supplied defaults for system passwords and other
        security parameters
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Protect Cardholder Data</term>
    <listitem>
     <orderedlist>
      <listitem override="3">
       <para>
        Protect stored cardholder data
       </para>
      </listitem>
      <listitem>
       <para>
        Encrypt transmission of cardholder data across open, public networks
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Maintain a Vulnerability Management Program</term>
    <listitem>
     <orderedlist>
      <listitem override="5">
       <para>
        Protect all systems against malware and regularly update anti-virus
        software or programs
       </para>
      </listitem>
      <listitem>
       <para>
        Develop and maintain secure systems and applications
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Implement Strong Access Control Measures</term>
    <listitem>
     <orderedlist>
      <listitem override="7">
       <para>
        Restrict access to cardholder data by business need to know
       </para>
      </listitem>
      <listitem>
       <para>
        Identify and authenticate access to system components
       </para>
      </listitem>
      <listitem>
       <para>
        Restrict physical access to cardholder data
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Regularly Monitor and Test Networks</term>
    <listitem>
     <orderedlist>
      <listitem override="10">
       <para>
        Track and monitor all access to network resources and cardholder data
       </para>
      </listitem>
      <listitem>
       <para>
        Regularly test security systems and processes
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Maintain an Information Security Policy</term>
    <listitem>
     <orderedlist>
      <listitem override="12">
       <para>
        Maintain a policy that addresses information security for all personnel
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   Most of the requirements described are organizational guidelines that
   help to ensure the security of all areas involved with cardholder data.
   The technical aspects are usually specified kind of fuzzy. This leads to
   a situation where it is up to the auditor to decide which security
   setting is valid for a requirement and which is not. So the described
   recommendations in this guide are just a starting point to fulfill the
   PCI DSS and are objects of discussion.
  </para>
 </sect1>
 <sect1>
  <title>Areas Relevant to the Operating System</title>
  <para>
   As the PCI DSS covers the complete picture of every aspect involved with
   credit cardholder data, not all requirements are directly operating
   system (OS) relevant. For instance the running application processing the
   data and the database design are not directly inside the scope of the OS
   security. Also formal processes that need to be implemented are not
   directly connected to the OS level. In detail we have the chapter 9
   (restrict physical access) and chapter 12 (maintain a policy) that are
   not discussed by this guide.
  </para>
  <para>
   Relevant are areas where the OS can be configured to enforce the policies
   described inside the requirements. This goes from system security
   settings and access control to system maintenance to protect against
   known security vulnerabilities.
  </para>
 </sect1>
 <sect1>
  <title>Requirements in Detail</title>
  <sect2>
   <title>Build and Maintain a Secure Network and Systems</title>
   <para/>
   <sect3>
    <title>Requirement 1: Install and Maintain a Firewall Configuration to Protect Cardholder Data</title>
    <para>
     The listed terms in this section are mostly design, documentation and
     formal process requirements. All changes to the firewalls and routers
     are need to be approved, documented and verified and all stakeholders
     need to be involved. The network design includes a DMZ environment,
     access to the Internet, a protected network for database servers,
     traffic filtering rules between network segments etc.
    </para>
    <para>
     In addition to a dedicated firewall and router, SUSE Linux Enterprise
     come with a host firewall based on iptables. The system can be easily
     configured to allow only connections on certain inbound ports. With the
     YaST firewall module it is also possible to define more complex rules,
     for instance that connections are only possible from certain network
     addresses. With this the local system firewall should be part of the
     overall firewall design to tighten network security to a maximum.
    </para>
    <para>
     The first technical point in requirement 1 is the identification of
     insecure services and protocols. After that it comes down to limiting
     the traffic to and from the system to tighten up the boundaries so that
     unneeded and unwanted traffic is directly avoided.
    </para>
    <variablelist>
     <varlistentry>
      <term>1.1.6.b Identify insecure services, protocols, and ports allowed; and verify that security features are documented for each service.</term>
      <listitem>
       <para>
        This task is embedded into the requirement to identify, document and
        justify all services and protocols running on a system. A special
        interest are services and protocols that could lead to a security
        risk. If a certain insecure service or protocol is used it needs to
        be evaluated and understood how big the security impact could be. A
        service or protocol that is not for business operation should be
        disabled or removed.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>1.2.1.b Examine firewall and router configurations to verify that inbound and outbound traffic is limited to that which is necessary for the cardholder data environment.</term>
      <listitem>
       <para>
        Inbound traffic filtering rules can be directly defined via the YaST
        firewall module. Systems with multiple interfaces can be configured
        in such a way that for example the ssh daemon is only reachable on
        the administration interface and not on the general network card.
        Furthermore is possible to define the source addresses that a service
        allows traffic from.
        </para>
        <para>
         Usually all outbound system traffic is generally allowed with the
         SuSEfirewall2 script. Therefore outbound rules need to be defined
         manually inside the SuSEfirewall2-custom script. The activation of
         the custom script has to be done inside the general SuSEfirewall
         configuration file
         <filename>/etc/sysconfig/SuSEfirewall2</filename> by uncommenting
         the <literal>FW_CUSTOMRULES</literal> line.
        </para>
        <para>
         To add an outbound rule simply add the needed iptables command
         inside the
         <literal>fw_custom_after_chain_creation()</literal> function. This
         function hook gets executed during the firewall setup and allows any
         customized iptables rule.
        </para>
        <para>
         The following example would only allow outbound DNS requests over
         interface eth0 to server 10.0.0.4.:
        </para>
        <screen>iptables -A OUTPUT -d 10.0.0.4/32 -o eth0 -p udp -m udp --dport 53 -j ACCEPT</screen>
        <para>
         Please check the <literal>deny all</literal> OUTPUT rule described
         in requirement 1.2.1.c.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>1.2.1.c Examine firewall and router configurations to verify that all other inbound and outbound traffic is specifically denied, for example by using an explicit <quote>deny all</quote> or an implicit deny after allow statement.</term>
      <listitem>
       <para>
        The "deny all" rules of other inbound and outbound traffic can easily
        be achieved with iptables. The INPUT and FORWARD table policies are
        directly set by the SuSEfirewall2 script so that all unwanted traffic
        gets dropped. (Forwarding is usually completely disabled by a kernel
        parameter and shouldn't be enabled for endpoint servers.)
       </para>
       <para>
        As mentioned before the OUTPUT policy has to be defined manually
        inside the SuSEfirewall2-custom script because in general all
        outgoing traffic is allowed. The following two rules need to be added
        to the fw_custom_after_chain_creation() function so that only
        outbound traffic that is related to an established inbound connection
        is allowed.
       </para>
       <screen>iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT</screen>
       <screen>iptables -P OUTPUT DROP</screen>
       <para>
        In addition inbound traffic can also be configured for certain
        services via the tcp wrapper configuration file "/etc/hosts.deny".
       </para>
       <para>
        Most of the following tasks are about examine and verifying that the
        defined inbound and outbound rules are really limiting the traffic
        between and within all network segments, like the DMZ and the
        Internet, to a needed minimum for full system operation.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>1.3.3 Implement anti-spoofing measures to detect and block forged source IP addresses from entering the network.</term>
      <listitem>
       <para>
        There a two ways to implement anti-spoofing measurements in SUSE Linux Enterprise.
       </para>
       <para>
        The first one is the use of iptables rules that only allow input from
        certain addresses on specified interfaces. The used address space for
        communications can be clearly defined by system setup. Any use of
        addresses that violate this definitions can be logged and trigger an
        alarm.
       </para>
       <para>
        The second way is provided via the Linux kernel reverse path
        filtering. The basic concept of this feature is that if a packet
        reply wouldn’t go out through the same interface the initial packet
        got in, it is treated as a bogus packet and is dropped. This feature
        is enabled by default in SUSE Linux Enterprise and can be check with
        the following command. This should give back a ‘1’ when it is enabled.
       </para>
       <screen>cat /proc/sys/net/ipv4/conf/all/rp_filter</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>1.3.5 Permit only “established” connections into the network.</term>
      <listitem>
       <para>
        The SuSEfirewall2 directly enables connection tracking via iptables.
        Connections to an interface that has been marked as external are
        dropped by default. Only connections that associated with an
        established connection are allowed.
       </para>
       <para>
        It is possible to define certain services that are allowed to connect
        to the external interface. However, this has to be in compliance with
        the general security policy.
       </para>
       <para>
        Please keep in mind that the first line of defense to block malicious
        connections from the internet should be a dedicated firewall system
        that handles all traffic and acts as a gate keeper. Unwanted
        connections should never reach the DMZ network. However, simple
        firewall rules on the SUSE Linux Enterprise systems can help to avoid
        misconfiguration issues and act as another line in the defense
        mechanism.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>1.3.7 Do not disclose private IP addresses and routing information to unauthorized parties.</term>
      <listitem>
       <para>
        A SUSE Linux Enterprise system can also act as a router to forward
        traffic from one interface to another network on a second interface.
        It is possible to use Network Address Translation (NAT) on the
        external interface so that no internal IP address is actually exposed
        to outside. This is done to mitigate the information an external
        attacker can gather by simply analyzing the network traffic. NAT can
        also be used on virtualization hosts or container based environments
        that connect to the outside via a specific interface.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 2: Do Not Use Vendor-Supplied Defaults for System Passwords and Other Security Parameters</title>
    <para>
     During system installation of SUSE Linux Enterprise general system
     passwords are already set by the administrator. The setup uses also a
     password checker (<command>cracklib</command>) that identifies weak
     entries against a common dictionary. So for most services the standard
     configuration comes already with customer defined security options.
    </para>
    <para>
     This is also stated inside the SUSE Linux Enterprise Server Security and
     Hardening Guide[1], that should be a general resource to tighten security
     further. This helps to meet the requirements in this section.
    </para>
    <variablelist>
     <varlistentry>
      <term>2.1 Always change vendor-supplied defaults and remove or disable unnecessary default accounts before installing a system on the network.</term>
      <listitem>
       <para>
        The configuration of any system service has to be evaluated to meet
        the needed security standards. This goes from limiting the used
        protocols to only allow currently secure versions and to disable
        legacy implementations, to the definition of access controls and
        authentication. SUSE Linux Enterprise predefined settings are already
        security aware, but settings can be tightened ever further.
       </para>
       <para>
        For example, this is the case with the SNMP daemon where by default
        incoming requests are only allowed to localhost. The default community
        string is named 'public' and should be changed before accepting
        general inbound connections.
       </para>
       <para>
        A second example are the default settings of the ssh daemon that are
        listed and commented out inside the sshd configuration file
        '/etc/ssh/sshd_config'. On default the insecure protocol 1 is already
        disabled. The same goes for permitting empty passwords
        (PermitEmptyPasswords no). To tighten ssh security it would best
        practice to deny direct root access by setting “PermitRootLogin” to no.
       </para>
       <para>
        Default settings can also be customized during automated system
        installation via an AutoYaST profile. This makes it easy to roll out
        new instances of SUSE Linux Enterprise Server and directly enable an
        evaluated configuration. The whole setup procedure can even be
        completely automated with the SUSE Manager[2].
       </para>
       <para>
        SUSE Linux Enterprise does not install additional default accounts
        apart of the root administration user. There are system accounts
        defined in /etc/passwd, but they are not activated and therefore not
        directly reachable. This can be validated by checking the lines inside
        the /etc/shadow file. The second column represents the defined
        password. An asterisk (*) at this place means that no password was
        ever defined and the account is therefore locked. An exclamation (!)
        stands for a locked account and can stand all by itself or in front of
        a password hash.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.2 Develop configuration standards for all system components. Assure that these standards address all known security vulnerabilities and are consistent with industry-accepted system hardening standards.</term>
      <listitem>
       <para>
        As mentioned inside the PCI DSS document, possible sources for
        industry-accepted hardening standards are:
       </para>
       <orderedlist>
        <listitem>
         <para>Center for Internet Security (CIS) </para>
        </listitem>
        <listitem>
         <para>International Organization for Standardization (ISO)</para>
        </listitem>
        <listitem>
         <para>SysAdmin Audit Network Security (SANS) Institute</para>
        </listitem>
        <listitem>
         <para>National Institute of Standards Technology (NIST)</para>
        </listitem>
       </orderedlist>
       <para>
        In general, as the PCI DSS requirements are quite fuzzy, there is no
        direct mapping of hardening standards to specific requirements.
        However, any hardening resource, including the SLES Security and
        Hardening Guide[1], help to fulfill this specifications.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.2.1 Implement only one primary function per server to prevent functions that require different security levels from co-existing on the same server. (For example, web servers, database servers, and DNS should be implemented on separate servers.)</term>
      <listitem>
       <para>
        With SUSE Linux Enterprise Server it is easily possible to separate
        services by using virtualization. SLES12 SP1 comes with the
        virtualization methods KVM, Xen, Linux Containers and Docker to
        isolate services. This makes it easy to fulfill the requirement and
        isolate services from each other.
       </para>
       <para>
        It is also possible to run SLES on proprietary virtualization servers
        like VMware ESX or Microsoft Hyper-V to achieve service separation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.2.2 Enable only necessary services, protocols, daemons, etc., as required for the function of the system.</term>
      <listitem>
       <para>
        This requirement is aligned with the firewall requirement 1.1.6.b to
        allow only services that are really needed and are using secure
        protocols and settings. All involved parties need to be aware of the
        impact of using insecure communication that could be comprised. The
        risk of using insecure protocols and/or services should be clearly
        understood and documented.
       </para>
       <para>
        Since SLES 12, enabling and disabling system services is done via
        systemd. Changes can be entered by using the
        <command>systemctl</command> tool:
       </para>
       <screen>systemctl status &lt;service&gt;</screen>
       <screen>systemctl enable &lt;service&gt;</screen>
       <screen>systemctl disable &lt;service&gt;</screen>
       <para>
        To list all available services that are installed on the system and
        see their status use the following command:
       </para>
       <screen>systemctl list-unit-files –type=service</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.2.3.a Inspect configuration settings to verify that security features are documented and implemented for all insecure services, daemons, or protocols.</term>
      <listitem>
       <para>
        One way to add an additional layer of security to insecure services is
        the usage of VPN tunnels (i.e. IPsec). With this, the network traffic
        of such services can be isolated and all data, internally and
        externally, is protected against eavesdropping. It must be clear that
        the communication is still insecure at the endpoints of the VPN tunnel
        and that this is just a workaround.
       </para>
       <para>
        Additional security within SUSE Linux Enterprise Server can also be
        provided with the usage of SELinux or AppArmor. At this stage the
        setup of these methods is beyond the scope of this document. A good
        starting point to get familiar with the SELinux framework is main
        chapter V of the SUSE Linux Enterprise Server 12 SP1 Security Guide.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.2.5.a Select a sample of system components and inspect the configurations to verify that all unnecessary functionality (for example, scripts, drivers, features, subsystems, file systems, etc.) is removed.</term>
      <listitem>
       <para>
        One main system component is the Linux kernel that consist of a core
        image that is extended by numerous kernel modules depending on the used
        hardware and system design. Network card drivers are automatically
        loaded depending on the availability inside the system and file system
        modules are used to extend the Linux kernel's functionality. The list
        of loaded kernel modules is usually quite long and includes modules
        that are only used occasionally. The kernel module framework makes it
        easy to blacklist certain modules and to limit the functionality.
       </para>
       <para>
        A simple way to block modules from being loaded is the configuration
        via the /etc/modprobe.d directory. For instance, if we would like to
        prevent the kernel module 'floppy' from being loaded, as systems these
        days have usually no floppy drive anymore, we create the following
        configuration file.
       </para>
       <para>
        File: /etc/modprobe.d/00-disable-modules.conf
       </para>
       <screen>install floppy /bin/true</screen>
       <para>
        Please be aware that the floppy module is usually loaded during the
        execution of the initial ram disk. Therefore it is necessary to
        propagate such a configuration change to the initrd file. This has to
        be done via the ''mkinitrd'' script.
       </para>
       <screen>mkinitrd</screen>
       <para>
        It is not that easy to do the same with application functionality.
        Usually the functionality is compiled into the binaries itself or be
        part of a library, which makes it impossible to being removed
        explicitly. Furthermore it has to be clear that removed files that
        where part of an RPM package are reinstalled when a package update is
        published.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>2.3 Encrypt all non-console administrative access using strong cryptography. Use technologies such as SSH, VPN, or TLS for web-based management and other non-console administrative access.</term>
      <listitem>
       <para>
        It is quite straightforward to fulfill this requirement. Any
        administrative network access needs to be encrypted. The first tool of
        choice here is SSH with appropriate configuration settings that fit
        into the security concept. Administrative access can also be granted
        via a website. In this case the complete connection chain between the
        browser and the server system needs to be encrypted. This is done via
        TLS and x509 certificates.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Protect Cardholder Data</title>
   <para/>
   <sect3>
    <title>Requirement 3: Protect Stored Cardholder Data</title>
    <para>
     The main prospect of this chapter is how to handle cardholder and
     authentication data securely. Cardholder data are information like the
     cardholder name and the Primary Account Number (PAN). Authentication
     data include the Personal Identification Number (PIN) and the Card
     Validation Code (CVC2). The main difference between cardholder data and
     authentication data is the fact that it is not allowed to store the
     authentication data in any case. The PAN on the other hand is allowed to
     be stored, but it needs to be encrypted and unreadable in case someone
     gains access to the stored data.
    </para>
    <para>
     As mentioned before in chapter 2 “Areas relevant to the Operating
     System” the used database design for saving cardholder data is not
     inside the scope of the OS. However, data encryption can be done in
     different ways. The DBMS can directly use column-level encryption inside
     the database scheme or the used files can be encrypted. The easiest way
     with SLES is to use full disk encryption so that the whole database
     storage is always encrypted. It has to be clear that access to the
     encrypted block device is the same as to a non encrypted disk. This is
     discussed in 3.4.1 in more detail.
    </para>
    <variablelist>
     <varlistentry>
      <term>3.4.1.a If disk encryption is used, inspect the configuration and observe the authentication process to verify that logical access to encrypted file systems is implemented via a mechanism that is separate from the native operating system's authentication mechanism (for example, not using local user account databases or general network login credentials).</term>
      <listitem>
       <para>
        The guidance description of the PCI DSS document says the following
        about this requirement: <quote>Full disk encryption helps to protect
        data in the event of physical loss of a disk and therefore may be
        appropriate for portable devices that store cardholder data.</quote>
       </para>
       <para>
        From the administrator point of view a block device encryption with
        the Linux Unified Key Setup (LUKS)/dm-crypt offers an abstraction
        layer that allows the usage of fully encrypted devices in the same way
        as non encrypted disks. Therefore access control can only be limited
        with the general ACL permissions that the used file system offers. To
        be compliant with this requirement the used decryption key cannot be
        associated with any general login credentials or authentication
        methods. With LUKS this is usually the case as the password needs to
        be entered separately during boot time, portable device insertion or
        manual disk activation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>3.4.1.c Examine the configurations and observe the processes to verify that cardholder data on removable media is encrypted wherever stored.</term>
      <listitem>
       <para>
        As described in the last section, LUKS/dm-crypt is a full disk
        encryption system that fulfills exactly this requirement. Access to
        the stored data is only possible via a decryption password that needs
        to be entered during disk insertion. The LUKS system in fully
        integrated into SLES and can be used via YaST to create new
        partitions.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 4: Encrypt Transmission of Cardholder Data Across Open, Public Networks</title>
    <para>
     Cardholder data has to be encrypted during transmissions over insecure
     networks. Best practice would be to try to encrypt all traffic,
     externally and internally, to make it as hard as possible for malicious
     individuals to gain inside information and possible privileged access to
     the cardholder data environment.
    </para>
    <variablelist>
     <varlistentry>
       <!-- FIXME: Weird structure, cf. below (this was a list too) -->
      <term>4.1 Use strong cryptography and security protocols (for example, TLS, IPSEC, SSH, etc.) to safeguard sensitive cardholder data during transmission over open, public networks, including the following: Only trusted keys and certificates are accepted, The protocol in use only supports secure versions or configurations, The encryption strength is appropriate for the encryption methodology in use.</term>
      <listitem>
       <para>
        Every connection that transmits sensitive information has to be
        protected against eavesdropping and tampering.
       </para>
       <para>
        For incoming client requests this can be done via HTTPS that is using
        a secure TLS connection. The authentication is done with a public
        x.509 certificate that proves to a certain level that the server is
        the right endpoint the customer is looking for.
       </para>
       <para>
        SLES comes with a set of services and tools that allow protected
        HTTPS connections, i.e. this can be directly done with the Apache
        HTTP Server or via stunnel that functions as a proxy to offer TLS
        encryption functionality.
       </para>
       <para>
        IPsec or other VPN technologies can be used for securing the
        connection between network segments that are connected via a public
        network. This connections can also be secured with a public x.509
        certificate. For internal usage it would be possible to use a private
        Certificate Authority (CA) to sign x.509 certificates and to keep
        track on trusted keys.
       </para>
       <para>
        In SLES this can be directly established with strongSwan that is a
        IPsec-based VPN solution or with OpenVPN that is using a custom
        security protocol.
       </para>
       <para>
        Administration access to the OS level is usually done via SSH.
        Configuration and authentication can be tightened to meet the needed
        security. This was partially stated before inside the requirements 1
        and 2.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Maintain a Vulnerability Management Program</title>
   <para/>
   <sect3>
    <title>Requirement 5: Protect All Systems Against Malware and Regularly Update Anti-Virus Software or Programs</title>
    <para>
     For PCI DSS compliance it is necessary to protect against malicious
     software threats. Commercial anti-virus software is available from the
     major anti-virus software vendors and can be integrated into the Linux
     environment. SLES itself comes with the open source anti-virus engine
     ClamAV.
    </para>
    <para>
     The question here is which functionality and performance is needed.
     ClamAV has a limited set of scanning capabilities and limited
     performance compared to commercial products. So the expectations have to
     be clear that ClamAV only gives only a simple protection level.
    </para>
    <para>
     On the other hand ClamAV is directly shipped with SLES and can be
     included during server installation. This makes it easy to fulfill the
     details of this requirement, but the drawbacks compared to commercial
     products have to be clearly understood.
    </para>
   </sect3>
   <sect3>
    <title>Requirement 6: Develop and maintain secure systems and applications</title>
    <para>
     A powerful instrument in SUSE Linux Enterprise is the command-line tool
     zypper that is an interface to the ZYpp system management library
     (libzypp). Among other things it solves packages, products, patterns and
     patches dependencies, has a locking mechanism to prevent package
     installation and provides a complete update stack to keep the system up
     to date and protected against know security issues. The zypper tool is
     part of any SLES installation and has direct access to the update
     repositories after system registration.
    </para>
    <para>
     For system management we provide SUSE Manager that provides an efficient
     way to keep systems up-to-date. It offers seamless management of both
     SUSE Linux Enterprise and Red Hat Enterprise Linux client systems. This
     is particularly handy in larger system environments, to check the
     current update status of each system and to react on know security risks.
    </para>
    <para>
     Most parts of this requirement are about in-house security software
     development, documentation and design questions. In this prospect we
     will keep our scope on how to keep the operating system maintained and
     secure.
    </para>
    <variablelist>
     <varlistentry>
      <!-- FIXME: Weird structure -->
      <term>6.2.a Examine policies and procedures related to security patch installation to verify processes are defined for:</term>
      <listitem>
       <orderedlist>
         <listitem>
           <para>
            Installation of applicable critical vendor-supplied security patches
            within one month of release.
           </para>
         </listitem>
         <listitem>
           <para>
            Installation of all applicable vendor-supplied security patches
            within an appropriate time frame (for example, within three months).
           </para>
         </listitem>
       </orderedlist>
       <para>
        The following command examples will show how to identify patches that
        need to be installed in order to run a secure system.
       </para>
       <para>
        First refresh all software repositories so that we have up-to-date information.
       </para>
       <screen>zypper refresh</screen>
       <para>
        Now we can look for important security fixes that have not yet been
        installed:
       </para>
       <screen>zypper list-patches --category security --severity important</screen>
       <para>
        It is also possible to search for CVE or SUSE Bugzilla numbers. By
        default only needed patches are listed by this commands. To show also
        patches that have already been installed use the --all switch.
       </para>
       <screen>zypper list-patches --all --cve=CVE-2016-4957</screen>
       <para>
        Details of individual patches can be listed with the patch-info
        sub-command:
       </para>
       <screen>zypper patch-info SUSE-SLE-SERVER-12-SP1-2016-600</screen>
       <para>
        To install only important security patches use the patch command. All
        zypper commands can be run with the --non-interactive switch to run
        automatically.
       </para>
       <screen>zypper patch --category security --severity important</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Implement Strong Access Control Measures</title>
   <para/>
   <sect3>
    <title>Requirement 7: Restrict access to cardholder data by business need to know</title>
    <para>Summary:</para>
    <para>
     Access control is a complex topic if it comes to the operating system.
     Again, the PCI DSS requirement is quite fuzzy at this point and does not
     specifically state to which degree the restriction has to be fulfilled.
     SUSE Linux Enterprise comes with all general Linux tools to limit and
     restrict access to certain system areas and components.
    </para>
    <para>
     Access can be controlled via specific users and groups of users. This
     are the traditional Unix permission settings. A more flexible mechanism
     for file systems are Access Control Lists (ACLs) that offer a more
     graduated approach. SELinux can be used to separate the system to a
     maximum and to protect processes from gaining more resources and access
     then allowed.
    </para>
    <para>
     As stated before, SELinux and AppArmor are not inside the scope of this
     guide. However, to protect critical systems that could be potentially
     targeted it would be a good idea to look into the capabilities of these
     security mechanisms further. A documentation how to set up and manage
     SELinux can be found in chapter V inside the SUSE Linux Enterprise
     Server 12 SP1 Security Guide.
    </para>
    <variablelist>
     <varlistentry>
      <term>7.1.2 Restrict access to privileged user IDs to least privileges necessary to perform job responsibilities.</term>
      <listitem>
       <para>
        The standard UNIX permissions allow the setting of Read, Write and
        Execution flags for user and group IDs. A general group called
        “Others” or “World” defines the access for users that do not fit into
        the first two groups. This allows a straight forward way to gain or
        deny access to file system resources.
       </para>
       <para>
        ACLs allow an extra level of restriction. It is possible to set
        read-write access for one user ID and only read access to a second
        one. The same goes for group IDs. The command-line tools are included
        inside the acl package and allow direct modification of file system
        resources.
       </para>
       <screen>getfacl /tmp/test.txt</screen>
       <screen>setfacl -m “u:dbuser:rw” /tmp/test.txt</screen>
       <screen>getfacl /tmp/test.txt</screen>
       <para>
        Standard Unix permissions come also with a so called StickyBit. This
        allows the execution of certain programs with higher privileges then
        the user who is executing those programs. The best example for this
        is the passwd tool that needs to modify the /etc/shadow in order to
        change the users password.
       </para>
       <para>
        In respect to the StickyBit Linux capabilities are also a way to
        explicitly allow certain operations or behaviors to binaries. An
        example for this is the ping command from the iputils package. It has
        no StickyBit but needs to be able to send ICMP IP packets over the
        network card. For this it has the CAP_NET_RAW capability that is
        Effective and Permitted (+ep).
       </para>
       <screen>getcap /usr/bin/ping</screen>
       <screen>/usr/bin/ping = cap_net_raw+ep</screen>
       <para>
        Login access control to the system can be managed via the pluggable
        authentication module (PAM) mechanism. There are several modules
        directly available in SUSE Linux Enterprise that allow setups like
        control of the login time, multiple authentication mechanisms and
        central databases like NIS, LDAP or Active Directory.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para/>
   </sect3>
   <sect3>
    <title>Requirement 8: <systemitem>Identify and authenticate access to system component</systemitem></title>
    <para>
     It is best practice to have a central database with user information and
     a unique identifier (UID) to grant or deny access to certain system
     components. This makes it easy to give administrators special access to
     group of servers or a database engineer permission to a certain DBMS
     system.
    </para>
    <para>
     On a standalone server unique identifiers are already managed via the
     standard Linux user and group IDs. These are listed inside /etc/passwd
     and /etc/group.
    </para>
    <variablelist>
     <varlistentry>
      <term>8.1.4 Remove/disable inactive user accounts within 90 days.</term>
      <listitem>
      <para>
       It should be common practice to use a centralized infrastructure for
       user accounts like NIS, LDAP or Active Directory. With this inactive
       accounts can easily identified and disabled automatically. A
       centralized infrastructure has also the advantage that a user account
       needs to be disabled in one place only. After access has been revoked
       a user is unable to perform any service that relies on the centralized
       account infrastructure.
      </para>
      <para>
       Local accounts on the other hand can be checked for inactivity during
       user login. This can be done with the pluggable authentication module
       (PAM) pam_lastlog. That module checks the last login time that was
       recorded in /var/log/lastlog and calculates the number of days since.
       By default access is denied when the inactivity reaches 90 days.
      </para>
      <para>
       To list the local accounts last login time use the lastlog command.
      </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>8.1.6 Limit repeated access attempts by locking out the user ID after not more than six attempts.</term>
      <listitem>
       <para>
        As already stated for requirement 8.1.4 a centralized account
        infrastructure will have this capability. On the SUSE Linux
        Enterprise system we can check and limit access attempts with the
        pam_tally2 PAM module. The module is executed during login time and
        checks the recorded failed attempts since the last successful login.
        The pam_tally2 command-line tool can be used to check and reset the
        account status.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>8.1.7 Set the lockout duration to a minimum of 30 minutes or until an administrator enables the user ID.</term>
      <listitem>
      <para>
       The pam_tally2 PAM module that was described in requirement 8.1.6 can
       be used to lock an account for a given time after a failed login
       attempt. The parameter ‘unlock_time=1800’ has to be configured into
       the PAM configuration. The default setting is that only the
       administrator can reactivate a locked account.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>8.3.1 Incorporate multi-factor authentication for all non-console access into the CDE for personnel with administrative access.</term>
      <listitem>
       <para>
        Multi-factor authentication for administrative access can be done via
        the pluggable authentication module (PAM) mechanism. This makes it
        flexible to add new methods to the authentication process and to
        adjust it if needed.
       </para>
       <para>
        Another way of multi-factor authentication for SSH connections is the
        additional usage of public keys. To connect to a system it is
        necessary to prove that you are in the possession of the appropriate
        private key. When accepted you need to enter a password at the second
        stage. With this brute force password crackers need to get there
        hands on a private key before they get a password prompt.
       </para>
       <para>
        Commercial one-time password (OTP) products usually have also a Linux
        PAM module available.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>8.3.2 Incorporate multi-factor authentication for all remote network access (both user and administrator, and including third-party access for support or maintenance) originating from outside the entity’s network.</term>
      <listitem>
       <para>See 8.3.1 for details.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 9: Restrict physical access to cardholder data</title>
    <para>Summary:</para>
    <para>Physical access to system that are involved in processing cardholder data are not inside the scope of general operating system security. Appropriate facility entry controls need to be in place in order to allow onside personnel employees and visitors to access systems directly.</para>
   </sect3>
  </sect2>
  <sect2>
   <title>Regularly Monitor and Test Networks</title>
   <para/>
   <sect3>
    <title>Requirement 10: Track and monitor all access to network resources and cardholder data</title>
    <para>
     A major key point to track user activities is a synchronized time
     reference. This is done via the NTP protocol that allows servers to keep
     their local time in sync with a central system. The central NTP server
     inside the cardholder data environment (CDE) should not relay on
     external connections to the internet to get the current time.
     Alternatively this can be done via a DCF77 radio transmission or GPS
     receiver.
    </para>
    <para>
     A synchronized time reference makes it easy to correlate events inside
     recorded log files. This can be general syslog entries collected by a
     central syslog server or kernel audit messages by the audit daemon.
    </para>
    <para>
     A good resource to get started with auditing and to understand the basic
     concepts is the chapter VI “The Linux Audit Framework” inside the SUSE
     Linux Enterprise Server 12 SP1 Security Guide. All subsections inside
     this requirement relevant to auditing can be fulfilled by defining
     appropriate auditing rules that can be saved inside a central storage.
    </para>
   </sect3>
   <sect3>
    <title>Requirement 11: Regularly Test Security Systems and Processes</title>
    <para>
     Testing the discussed security mechanisms is also a key requirement for
     PCI DSS. Evaluating the configurations and testing logging mechanisms
     can protect against know security risks and ensure that essential
     information are available to identify possible security breaches.
     Testing capabilities should be already considered during system design.
    </para>
    <para>
     AIDE: To keep track of the systems integrity SUSE Linux Enterprise comes
     with the Advanced Intrusion Detection Environment (AIDE). It creates a
     hash value database of all relevant OS files. After initialization it
     can be used to verify the integrity of all previously saved files. A
     database snapshot should be created regularly and saved on a central
     system to evaluate possible modifications.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>Maintain an Information Security Policy</title>
   <para/>
   <sect3>
    <title>Requirement 12: Maintain a Policy That Addresses Information Security for All Personnel</title>
    <para>
     A general security policy should be part of any organization that
     handles protect-worthy information. All relevant aspects should be
     included to make it clear for employees and stakeholders about possible
     risks and how to avoid them.
    </para>
    <para>
     A security policies should also be evaluated regularly and adjusted to
     keep the protection level as high as possible.
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1>
   <title>Abbreviations used in the Document</title>
   <para>
    The following abbreviations where used in this document.
   </para>
    <informaltable>
      <tgroup cols="2"><tbody><row><entry><para>PCI DSS</para></entry><entry><para>Payment Card Industry Data Security Standard</para></entry></row><row><entry><para>CDE</para></entry><entry><para>Cardholder Data Environment</para></entry></row><row><entry><para>OTP</para></entry><entry><para>One Time Password</para></entry></row><row><entry><para>SSC</para></entry><entry><para>Security Standards Council</para></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row><row><entry><para/></entry><entry><para/></entry></row></tbody></tgroup>
    </informaltable>
    <para/>
  </sect1>
</article>
