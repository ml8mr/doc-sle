<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE appendix
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<appendix xml:id="app.pcidss"
 xmlns="http://docbook.org/ns/docbook" version="5.0"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Achieving &pcidssa; Compliance</title>
 <info>
  <abstract>
   <para>
    To protect customers and the business itself, companies that handle
    credit card payments need to keep data as safe and secure as possible.
    Following the &pcidss; helps to secure all areas that are connected to
    payment processes and to implement security-relevant actions to keep the
    data and the computing environment safe.
   </para>
  </abstract>
 </info>

 <!-- Possibly useful resources:
 Positive Research Center (describing PCI-DSS 1.0!)
 + (Part 1) http://blog.ptsecurity.com/2010/07/red-card-specificity-of-pci-dss-in.html
 + (Part 2) http://blog.ptsecurity.com/2010/07/red-card-specificity-of-pci-dss-in_19.html
 + (Part 3) http://blog.ptsecurity.com/2010/08/pci-dss-and-red-hat-enterprise-linux.html
 + (Part 4) http://blog.ptsecurity.com/2010/09/pci-dss-and-red-hat-enterprise-linux.html
 + (Part 5) http://blog.ptsecurity.com/2010/09/pci-dss-and-red-hat-enterprise-linux_03.html
 + (Part 6) http://blog.ptsecurity.com/2010/10/pci-dss-and-red-hat-enterprise-linux.html
 + (Part 7) http://blog.ptsecurity.com/2010/10/pci-dss-and-red-hat-enterprise-linux_20.html
 + (Part 8) http://blog.ptsecurity.com/2010/11/requirement-10-track-and-monitor-all.html
 + (Part 9) http://blog.ptsecurity.com/2010/11/pci-dss-and-red-hat-enterprise-linux.html

 NetIQ (for cross-BU promotion) (note that Novell Sentinel was
 renamed to NetIQ Sentinel at some point):
 + https://www.netiq.com/industries/federal/regulations-standards-compliance/pci-dss.html
 -->

 <para>
  An essential part of implementing &pcidssa; is the combination of actions.
  It is not only necessary
  to configure a service to be secure, but it is also important that the
  configuration is not changed afterward. If something was changed, it is
  important to keep track on who changed what at which point in time.
 </para>
 <para>
  This document should give you a basic understanding of how
  &productname; can be configured to comply with the &pcidss;.
 </para>
 <para>
  Again, it is most important to understand that protecting the systems does
  not end by the configuration. It is the whole environment and people
  involved that needs to be taken into account.
 </para>
 <sect1 xml:id="sec.pcidss.what">
  <title>What is &pcidssa;?</title>
  <para>
   The &pcidss; (&pcidssa;) is a set of
   requirements to guide a merchant to protect credit cardholder data. The
   standard covers 6 main categories with currently 12 requirement topics
   how to implement, protect, maintain and monitor systems that are involved
   with credit cardholder data processing.
  </para>
  <para>
   &pcidssa; was created and is maintained by the PCI Security Standards
   Council (SSC) that was founded by all five major credit card brands Visa,
   MasterCard, American Express, Discover, and JCB. In December 2004, &pcidssa;
   1.0 was released to address the growing thread of online credit card
   fraud. The current version, &pcidssa; version 3.2 has been available since
   April 2016.
  </para>
  <variablelist>
   <varlistentry>
    <term>Build and Maintain a Secure Network and Systems</term>
    <listitem>
     <orderedlist>
      <listitem>
       <para>
        Install and maintain a firewall configuration to protect cardholder
        data
       </para>
      </listitem>
      <listitem>
       <para>
        Do not use vendor-supplied defaults for system passwords and other
        security parameters
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Protect Cardholder Data</term>
    <listitem>
     <orderedlist>
      <listitem override="3">
       <para>
        Protect stored cardholder data
       </para>
      </listitem>
      <listitem>
       <para>
        Encrypt transmission of cardholder data across open, public networks
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Maintain a Vulnerability Management Program</term>
    <listitem>
     <orderedlist>
      <listitem override="5">
       <para>
        Protect all systems against malware and regularly update anti-virus
        software or programs
       </para>
      </listitem>
      <listitem>
       <para>
        Develop and maintain secure systems and applications
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Implement Strong Access Control Measures</term>
    <listitem>
     <orderedlist>
      <listitem override="7">
       <para>
        Restrict access to cardholder data by business need to know
       </para>
      </listitem>
      <listitem>
       <para>
        Identify and authenticate access to system components
       </para>
      </listitem>
      <listitem>
       <para>
        Restrict physical access to cardholder data
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Regularly Monitor and Test Networks</term>
    <listitem>
     <orderedlist>
      <listitem override="10">
       <para>
        Track and monitor all access to network resources and cardholder data
       </para>
      </listitem>
      <listitem>
       <para>
        Regularly test security systems and processes
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Maintain an Information Security Policy</term>
    <listitem>
     <orderedlist>
      <listitem override="12">
       <para>
        Maintain a policy that addresses information security for all personnel
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   Most requirements of &pcidssa; are organizational guidelines that
   help ensure the security of all areas involved with cardholder data.
   The wording of technical aspects is usually unspecific.
  </para>
  <para>
   This means, it is up to auditors to decide which security settings are
   valid for a requirement and which are not. Therefore, the recommendations
   in this document can only provide a starting point for implementing the
   &pcidssa; and are necessarily subject to discussion.
  </para>
 </sect1>
 <sect1 xml:id="sec.pcidss.os-relevant">
  <title>Focus of This Document: Areas Relevant to the Operating System</title>
  <para>
   The &pcidssa; covers many aspects related to cardholder data. Not all of
   these aspects have bearing on the operating system and this document will
   not focus on these. Instead, this document focuses on aspects that affect
   OS configuration, including:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     System security
    </para>
   </listitem>
   <listitem>
    <para>
     Access control
    </para>
   </listitem>
   <listitem>
    <para>
     System maintenance to protect against known vulnerabilities
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Conversely, this document does not concern itself with aspects not within
   the scope of OS security. For example, this includes data processing
   applications, database design, and formal processes outside of the OS
   scope. In particular, requirement 9 (restrict physical access) and
   requirement 12 (maintain a policy) are not discussed by this document.
  </para>
 </sect1>
 <sect1 xml:id="sec.pcidss.requirement">
  <title>Requirements in Detail</title>
  <sect2>
   <title>Build and Maintain a Secure Network and Systems</title>
   <para/>
   <sect3>
    <title>Requirement 1: Install and Maintain a Firewall Configuration to Protect Cardholder Data</title>
    <para>
     The listed terms in this section are mostly design, documentation and
     formal process requirements. All changes to the firewalls and routers
     are need to be approved, documented and verified and all stakeholders
     need to be involved. The network design includes a DMZ environment,
     access to the Internet, a protected network for database servers,
     traffic filtering rules between network segments etc.
    </para>
    <para>
     In addition to a dedicated firewall and router, &productname;
     come with a host firewall based on iptables. The system can be easily
     configured to allow only connections on certain inbound ports. With the
     &yast; firewall module it is also possible to define more complex rules,
     for example, that connections are only possible from certain network
     addresses. With this, the local system firewall should be part of the
     overall firewall design to tighten network security to a maximum.
    </para>
    <para>
     The first technical point in requirement 1 is the identification of
     insecure services and protocols. After that it comes down to limiting
     the traffic to and from the system to tighten up the boundaries so that
     unneeded and unwanted traffic is directly avoided.
    </para>
    <variablelist>
     <varlistentry xml:id="vle.pcidss.insecure-service">
      <term>
       1.1.6.b Identify insecure services, protocols, and ports allowed; and
       verify that security features are documented for each service.
      </term>
      <listitem>
       <para>
        This task is embedded into the requirement to identify, document and
        justify all services and protocols running on a system. A special
        interest are services and protocols that could lead to a security
        risk. If an insecure service or protocol is used it needs to
        be evaluated and understood what its security impact could be.
        Services or protocols that are not necessary for the business to
        function should be disabled or removed.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="vle.pcidss.firewall">
      <term>
       1.2.1.b Examine firewall and router configurations to verify that
       inbound and outbound traffic is limited to that which is necessary for
       the cardholder data environment.
      </term>
      <listitem>
       <para>
        Inbound traffic filtering rules can be directly defined via the &yast;
        firewall module. Systems with multiple interfaces can be configured
        in such a way that, for example, the SSH daemon is only reachable on
        the administration interface and not on the general network card.
        Furthermore is possible to define the source addresses that a service
        allows traffic from.
        </para>
        <para>
         Usually all outbound system traffic is generally allowed with the
         &susefirewall; script. Therefore outbound rules need to be defined
         manually inside the &susefirewall; custom script. The activation of
         the custom script needs to be done inside the general &susefirewall;
         configuration file
         <filename>/etc/sysconfig/SuSEfirewall2</filename> by uncommenting
         the <literal>FW_CUSTOMRULES</literal> line.
        </para>
        <para>
         To add an outbound rule, add an appropriate
         <command>iptables</command> command line inside the
         <literal>fw_custom_after_chain_creation()</literal> function. This
         function hook is executed during the firewall setup and allows any
         customized <systemitem>iptables</systemitem> rule.
        </para>
        <para>
         For example, to allow only outbound DNS requests over the
         interface <systemitem>eth0</systemitem> to server
         <systemitem class="ipaddress">10.0.0.4</systemitem>, use:
        </para>
        <screen>iptables -A OUTPUT -d 10.0.0.4/32 -o eth0 -p udp -m udp --dport 53 -j ACCEPT</screen>
        <para>
         Also see the <literal>deny all OUTPUT</literal> rule described
         in <xref linkend="vle.pcidss.deny-all"/>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="vle.pcidss.deny-all">
      <term>
       1.2.1.c Examine firewall and router configurations to verify that all
       other inbound and outbound traffic is specifically denied, for example
       by using an explicit <quote>deny all</quote> or an implicit
       <quote>deny after allow</quote> statement.
      </term>
      <listitem>
       <para>
        The <quote>deny all</quote> rules of other inbound and outbound
        traffic can easily be achieved with iptables. The
        <literal>INPUT</literal> and <literal>FORWARD</literal> table
        policies are directly set by the &susefirewall; script, so all
        unwanted traffic is dropped. Forwarding is usually completely
        disabled by a kernel parameter and should not be enabled for endpoint
        servers.
       </para>
       <para>
        <!-- fixme: wording -->As mentioned before the OUTPUT policy needs to be defined manually
        inside the custom &susefirewall; script because in general all
        outgoing traffic is allowed. The following two rules need to be added
        to the <literal>fw_custom_after_chain_creation()</literal> function
        so that only
        outbound traffic that is related to an established inbound connection
        is allowed.
       </para>
       <screen>iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT</screen>
       <screen>iptables -P OUTPUT DROP</screen>
       <para>
        In addition inbound traffic can also be configured for certain
        services via the tcp wrapper configuration file
        <filename>/etc/hosts.deny</filename>.
       </para>
       <para>
        Most of the following tasks are about examine and verifying that the
        defined inbound and outbound rules are really limiting the traffic
        between and within all network segments, like the DMZ and the
        Internet, to a needed minimum for full system operation.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       1.3.3 Implement anti-spoofing measures to detect and block forged
       source IP addresses from entering the network.
      </term>
      <listitem>
       <para>
        There a two ways to implement anti-spoofing measurements in &productname;:
       </para>
       <itemizedlist>
        <listitem>
         <formalpara>
          <title><systemitem>iptables</systemitem> rules that only allow input from certain addresses on specified interfaces</title>
          <para>
           The used address space for
           communications can be clearly defined in the system setup. Any use of
           addresses that violate these definitions can be logged and trigger an
           alarm.
          </para>
         </formalpara>
        </listitem>
        <listitem>
         <formalpara>
          <title>Linux Kernel Reverse Path Filtering</title>
          <para>
           The basic concept of this feature is that if a packet
           reply would not go out through the same interface the initial packet
           got in, it is treated as a bogus packet and is dropped. This feature
           is enabled by default in &productname; and can be check with
           the following command:
          </para>
         </formalpara>
         <screen>cat /proc/sys/net/ipv4/conf/all/rp_filter</screen>
         <para>
          When enabled, this returns
          <literal>1</literal>.
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       1.3.5 Permit only <quote>established</quote> connections into the
       network.
      </term>
      <listitem>
       <para>
        The &susefirewall; directly enables connection tracking via iptables.
        Connections to an interface that needs been marked as external are
        dropped by default. Only connections that associated with an
        established connection are allowed.
       </para>
       <para>
        It is possible to define certain services that are allowed to connect
        to the external interface. However, this needs to be in compliance with
        the general security policy.
       </para>
       <para>
        Keep in mind that the first line of defense to block malicious
        connections from the Internet should be a dedicated firewall system
        that handles all traffic and acts as a gate keeper. Unwanted
        connections should never reach the DMZ network. However, simple
        firewall rules on the &productname; systems can help to avoid
        misconfiguration issues and act as another line in the defense
        mechanism.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       1.3.7 Do not disclose private IP addresses and routing information to unauthorized parties.
      </term>
      <listitem>
       <para>
        A &productname; system can also act as a router to forward
        traffic from one interface to another network on a second interface.
        It is possible to use Network Address Translation (NAT) on the
        external interface so that no internal IP address is actually exposed
        to outside. This is done to mitigate the information an external
        attacker can gather by simply analyzing the network traffic. NAT can
        also be used on virtualization hosts or container based environments
        that connect to the outside via a specific interface.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 2: Do Not Use Vendor-Supplied Defaults for System Passwords and Other Security Parameters</title>
    <para>
     During system installation of &productname; general system
     passwords are already set by the administrator. The setup uses also a
     password checker (<command>cracklib</command>) that identifies weak
     entries against a common dictionary. So for most services the standard
     configuration comes already with customer-defined security options.
    </para>
    <para>
     As general resource to tighten security further, see
     <xref linkend="book.security"/> and <xref linkend="book.hardening"/>.
     <!-- FIXME: These guides may become one soon. - sknorr, 2017-12-01 -->
    </para>
    <variablelist>
     <varlistentry>
      <term>
       2.1 Always change vendor-supplied defaults and remove or disable
       unnecessary default accounts before installing a system on the network.
      </term>
      <listitem>
       <para>
        The configuration of any system service needs to be evaluated to meet
        the needed security standards. This goes from limiting the used
        protocols to only allow currently secure versions and to disable
        legacy implementations, to the definition of access controls and
        authentication. &productname; predefined settings already provide
        good general security, but settings can be tightened further.
       </para>
       <para>
        For example, the following security settings might be relevant:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <!-- FIXME: content correct? - sknorr, 2017-12-06 -->
          By default, the SNMP daemon only allows incoming requests to
          <systemitem>localhost</systemitem>. However, the default community
          string is named <literal>public</literal> and should be changed
          before accepting general inbound connections.
         </para>
        </listitem>
        <listitem>
         <para>
          By default, certain insecure upstream settings of the
          <systemitem class="daemon">sshd</systemitem> daemon are listed and
          commented out inside the <systemitem class="daemon">sshd</systemitem>
          configuration file <filename>/etc/ssh/sshd_config</filename>. For
          example, the insecure protocol version 1 and empty passwords
          (<literal>PermitEmptyPasswords no</literal>) are already disabled.
         </para>
         <para>
          To further tighten SSH security, if applicable, deny direct
          <systemitem class="username">root</systemitem> access by setting
          <literal>PermitRootLogin</literal> to <literal>no</literal>.
         </para>
        </listitem>
       </itemizedlist>
       <para>
        Default settings can be customized by automating system installation
        with an &ay; profile. This makes it easy to roll out new instances of
        &productname; and directly enable an evaluated configuration. This
        setup procedure can also be automated with the &susemgr;. For more
        information, see the &susemgr; documentation at
        <link xlink:href="https://www.suse.com/documentation/suse-manager"/>.
       </para>
       <para>
        &productname; does not install additional default accounts apart from
        the root administration user. There are system accounts defined in
        <filename>/etc/passwd</filename>, but they are not activated and
        therefore not directly reachable. This can be validated by checking
        the lines inside the <filename>/etc/shadow</filename> file.
       </para>
       <para>
        In that file, the second column represents the defined password. An
        asterisk (<literal>*</literal>) means that no password was ever
        defined and the account is therefore locked. An exclamation
        (<literal>!</literal>) stands for a locked account and can stand all
        by itself or in front of a password hash.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.2 Develop configuration standards for all system components. Assure
       that these standards address all known security vulnerabilities and
       are consistent with industry-accepted system hardening standards.
      </term>
      <listitem>
       <para>
        As mentioned inside the &pcidssa; document, possible sources for
        industry-accepted hardening standards are:
       </para>
       <orderedlist>
        <listitem>
         <para>Center for Internet Security (CIS) </para>
        </listitem>
        <listitem>
         <para>International Organization for Standardization (ISO)</para>
        </listitem>
        <listitem>
         <para>SysAdmin Audit Network Security (SANS) Institute</para>
        </listitem>
        <listitem>
         <para>National Institute of Standards Technology (NIST)</para>
        </listitem>
       </orderedlist>
       <para>
        In general, as the &pcidssa; requirements are quite fuzzy, there is no
        direct mapping of hardening standards to specific requirements.
        However, other hardening resources will also help fulfill these
        specifications, including <xref linkend="book.security"/> and
        <xref linkend="book.hardening"/>.
        <!-- FIXME: These guides may become one soon. - sknorr, 2017-12-01 -->
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.2.1 Implement only one primary function per server to prevent
       functions that require different security levels from co-existing on
       the same server. (For example, web servers, database servers, and DNS
       should be implemented on separate servers.)
      </term>
      <listitem>
       <para>
        With &productname; it is easily possible to separate
        services by using virtualization. &productname; &productnumber; comes with the
        virtualization methods &kvm;, &xen;, &lxc; and &docker; to
        isolate services. This makes it easy to fulfill the requirement and
        isolate services from each other.<!-- fixme: wording -->
       </para>
       <para>
        It is also possible to run &productname; on proprietary virtualization servers
        like &esx; or &hyperv; to achieve service separation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.2.2 Enable only necessary services, protocols, daemons, etc., as
       required for the function of the system.
      </term>
      <listitem>
       <para>
        This requirement is aligned with the a subrequirement of
        requirement 1 (<xref linkend="vle.pcidss.insecure-service"/>) to
        allow only services that are really needed and are using secure
        protocols and settings. All parties involved need to be aware of the
        impact of using insecure communication. Research, clearly document
        and communicate the risk of using insecure protocols and services.
       </para>
       <para>
        Enable and disable system services with <command>systemctl</command>:
       </para>
       <screen>systemctl status <replaceable>SERVICE</replaceable></screen>
       <screen>systemctl enable <replaceable>SERVICE</replaceable></screen>
       <screen>systemctl disable <replaceable>SERVICE</replaceable></screen>
       <para>
        To list all available services that are installed on the system and
        see their status use the following command:
       </para>
       <screen>systemctl list-unit-files –type=service</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.2.3.a Inspect configuration settings to verify that security features
       are documented and implemented for all insecure services, daemons, or
       protocols.
      </term>
      <listitem>
       <para>
        One way to add an additional layer of security to insecure services is
        the usage of VPN tunnels (for example, IPsec). With this, the network
        traffic
        of such services can be isolated and all data, internally and
        externally, is protected against eavesdropping. It must be clear that
        the communication is still insecure at the endpoints of the VPN tunnel
        and that this is only a workaround.
       </para>
       <para>
        Additional security within &productname; can also be
        provided with the usage of &selnx; or &aa;. At this stage the
        setup of these methods is beyond the scope of this document. For
        information about &selnx; framework, see
        <xref linkend="cha.selinux"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.2.5.a Select a sample of system components and inspect the
       configurations to verify that all unnecessary functionality (for
       example, scripts, drivers, features, subsystems, file systems, etc.)
       is removed.
      </term>
      <listitem>
       <para>
        One main system component is the Linux kernel that consist of a core
        image that is extended by numerous kernel modules depending on the used
        hardware and system design. Network card drivers are automatically
        loaded depending on the availability inside the system and file system
        modules are used to extend the Linux kernel's functionality. The list
        of loaded kernel modules is usually quite long and includes modules
        that are only used occasionally. The kernel module framework makes it
        easy to blacklist certain modules and to limit the functionality.
       </para>
       <para>
        A simple way to block modules from being loaded is the configuration
        via the directory <filename>/etc/modprobe.d</filename>. For example, to
        prevent the kernel module <literal>floppy</literal> from being loaded,
        as systems these
        days have usually no floppy drive anymore, create a
        configuration file
        <filename>/etc/modprobe.d/00-disable-modules.conf</filename> with the
        following content:
       </para>
       <screen>install floppy /bin/true</screen>
       <para>
        Be aware that the <literal>floppy</literal> module is usually loaded during the
        execution of the initial RAM disk. Therefore it is necessary to
        propagate such a configuration change to the
        <filename>initrd</filename> file. This needs to be done via the
        <command>mkinitrd</command> script.
       </para>
       <screen>mkinitrd</screen>
       <para>
        It is not that easy to do the same with application functionality.
        Usually the functionality is compiled into the binaries itself or be
        part of a library, which makes it impossible to being removed
        explicitly. Furthermore, it needs to be clear that removed files that
        were part of an RPM package are reinstalled when a package update is
        published.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       2.3 Encrypt all non-console administrative access using strong
       cryptography. Use technologies such as SSH, VPN, or TLS for web-based
       management and other non-console administrative access.
      </term>
      <listitem>
       <para>
        Following this requirement is straightforward: Encrypt all
        administrative network access.
       </para>
       <para>
        The first tool of
        choice here is SSH with appropriate configuration settings that fit
        into the security concept. Administrative access can also be granted
        via a Web site. In this case the complete connection chain between the
        browser and the server system needs to be encrypted. This is done via
        TLS and X.509 certificates.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Protect Cardholder Data</title>
   <para/>
   <sect3>
    <title>Requirement 3: Protect Stored Cardholder Data</title>
    <para>
     The main prospect of this chapter is how to handle cardholder and
     authentication data securely. Cardholder data are information like the
     cardholder name and the Primary Account Number (PAN). Authentication
     data include the Personal Identification Number (PIN) and the Card
     Validation Code (CVC2). The main difference between cardholder data and
     authentication data is the fact that it is not allowed to store the
     authentication data in any case. The PAN on the other hand is allowed to
     be stored, but it needs to be encrypted and unreadable in case someone
     gains access to the stored data.
    </para>
    <para>
     As mentioned in <xref linkend="sec.pcidss.os-relevant"/>,
     the database design used for saving cardholder data is not
     within the scope of the OS. However, data can be encrypted in
     different ways:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       The DBMS can directly use column-level encryption inside the database
       scheme or the used files can be encrypted.
      </para>
     </listitem>
     <listitem>
      <para>
       &productname; supports full-disk encryption, so that the whole
       database storage is always encrypted. However, access to an encrypted
       disk works the same way as to a non-encrypted disk. This is discussed
       in more detail in requirement 3.4.1.
      </para>
     </listitem>
    </itemizedlist>
    <variablelist>
     <varlistentry>
      <term>
       3.4.1.a If disk encryption is used, inspect the configuration and
       observe the authentication process to verify that logical access to
       encrypted file systems is implemented via a mechanism that is separate
       from the native operating system's authentication mechanism (for
       example, not using local user account databases or general network
       login credentials).
      </term>
      <listitem>
       <para>
        The guidance description of the &pcidssa; document says the following
        about this requirement: <quote>Full disk encryption helps to protect
        data in the event of physical loss of a disk and therefore may be
        appropriate for portable devices that store cardholder data.</quote>
       </para>
       <para>
        From the administrator point of view a block device encryption with
        the Linux Unified Key Setup (LUKS)/dm-crypt offers an abstraction
        layer that allows the usage of fully encrypted devices in the same way
        as non encrypted disks. Therefore access control can only be limited
        with the general ACL permissions that the used file system offers. To
        be compliant with this requirement the used decryption key cannot be
        associated with any general login credentials or authentication
        methods. With LUKS this is usually the case as the password needs to
        be entered separately during boot time, portable device insertion or
        manual disk activation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       3.4.1.c Examine the configurations and observe the processes to verify
       that cardholder data on removable media is encrypted wherever stored.
      </term>
      <listitem>
       <para>
        As described in the last section, LUKS/dm-crypt is a full disk
        encryption system that fulfills exactly this requirement. Access to
        the stored data is only possible via a decryption password that must
        be entered when the disk is mounted. The LUKS system in fully
        integrated into &productname; and can be used via &yast; to create new
        partitions.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 4: Encrypt Transmission of Cardholder Data Across Open, Public Networks</title>
    <para>
     Cardholder data needs to be encrypted during transmissions over insecure
     networks. Best practice would be to try to encrypt all traffic,
     externally and internally, to make it as hard as possible for malicious
     individuals to gain inside information and possible privileged access to
     the cardholder data environment.
    </para>
    <variablelist>
     <varlistentry>
      <term>
       4.1 Use strong cryptography and security protocols (for example,
       TLS, IPSEC, SSH, etc.) to safeguard sensitive cardholder data during
       transmission over open, public networks, including the following: (1)
       Only trusted keys and certificates are accepted, (2) The protocol in
       use only supports secure versions or configurations, (3) The
       encryption strength is appropriate for the encryption methodology in
       use.
      </term>
      <listitem>
       <para>
        Every connection that transmits sensitive information needs to be
        protected against eavesdropping and tampering.
       </para>
       <para>
        For incoming client requests, use the HTTPS protocol with a secure
        TLS connection. The authentication is done with a public
        x.509 certificate that proves to a certain level that the server is
        the right endpoint the customer is looking for.
       </para>
       <para>
        &productname; comes with a set of services and tools that allow
        protected HTTPS connections. For example, this can be directly done
        with the Apache HTTP Server or via <command>stunnel</command> that
        functions as a proxy to offer TLS encryption functionality.
       </para>
       <para>
        IPsec or other VPN technologies can be used for securing the
        connection between network segments that are connected via a public
        network. Such connections can also be secured with a public x.509
        certificate. For internal usage it would be possible to use a private
        Certificate Authority (CA) to sign x.509 certificates and to keep
        track on trusted keys.
       </para>
       <para>
        In &productname; this can be directly established with
        <phrase role="productname">strongSwan</phrase> that is a IPsec-based
        VPN solution or with OpenVPN that is using a custom security protocol.
       </para>
       <para>
        Administration access to the OS level is usually done via SSH.
        Configuration and authentication can be tightened to meet the needed
        security. This was partially stated before inside the requirements 1
        and 2.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Maintain a Vulnerability Management Program</title>
   <para/>
   <sect3>
    <title>Requirement 5: Protect All Systems Against Malware and Regularly Update Anti-Virus Software or Programs</title>
    <para>
     For &pcidssa; compliance it is necessary to protect against malicious
     software threats. Commercial anti-virus software is available from the
     major anti-virus software vendors and can be integrated into the Linux
     environment. &productname; itself comes with the open source anti-virus engine
     &clamav;.
    </para>
    <para>
     The question here is which functionality and performance is needed.
     &clamav; has a limited set of scanning capabilities and limited
     performance compared to commercial products. So the expectations need to
     be clear that &clamav; only gives only a simple protection level.
    </para>
    <para>
     On the other hand &clamav; is directly shipped with &productname; and can be
     included during server installation. This makes it easy to fulfill the
     details of this requirement, but the drawbacks compared to commercial
     products need to be clearly understood.
    </para>
   </sect3>
   <sect3>
    <title>Requirement 6: Develop and maintain secure systems and applications</title>
    <para>
     A powerful instrument in &productname; is the tool
     <command>zypper</command> that is an interface to the ZYpp system management library
     (libzypp). Among other things, it solves<!--fixme: wording--> packages, products, patterns and
     patches dependencies, has a locking mechanism to prevent package
     installation and provides a complete update stack to keep the system up
     to date and protected against know security issues. <command>zypper</command> is
     part of any &productname; installation and has direct access to the update
     repositories after system registration.
    </para>
    <para>
     For system management we provide &susemgr; that provides an efficient
     way to keep systems up-to-date. It offers seamless management of both
     &productname; and &rhel; client systems. This
     is particularly handy in larger system environments, to check the
     current update status of each system and to react on know security risks.
    </para>
    <para>
     Most parts of this requirement are about in-house security software
     development, documentation and design questions. In this prospect we
     will keep our scope on how to keep the operating system maintained and
     secure.
    </para>
    <variablelist>
     <varlistentry>
      <term>
       6.2.a Examine policies and procedures related to security patch
       installation to verify processes are defined for: (1) Installation of
       applicable critical vendor-supplied security patches within one month
       of release, (2) Installation of all applicable vendor-supplied
       security patches within an appropriate time frame (for example, within
       three months).
      </term>
      <listitem>
       <para>
        To identify patches that
        need to be installed to secure your system, do the following:
       </para>
       <!-- FIXME: procedure -->
       <para>
        First refresh all software repositories so that we have up-to-date information.
       </para>
       <screen>zypper refresh</screen>
       <para>
        Now we can look for important security fixes that have not yet been
        installed:
       </para>
       <screen>zypper list-patches --category security --severity important</screen>
       <para>
        It is also possible to search for CVE or SUSE Bugzilla numbers. By
        default only needed patches are listed by this command. To show also
        patches that have already been installed use <option>--all</option>:
       </para>
       <screen>zypper list-patches --all --cve=CVE-2016-4957</screen>
       <para>
        Details of individual patches can be listed with the patch-info
        subcommand:
       </para>
       <screen>zypper patch-info SUSE-SLE-SERVER-12-SP1-2016-600</screen>
       <para>
        To install only important security patches use the patch command. All
        <command>zypper</command> commands can be run with the <option>--non-interactive</option> to run
        automatically<!--fixme: wording-->:
       </para>
       <screen>zypper patch --category security --severity important</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
  <sect2>
   <title>Implement Strong Access Control Measures</title>
   <para/>
   <sect3>
    <title>Requirement 7: Restrict access to cardholder data by business need to know</title>
    <para>Summary:</para>
    <para>
     Access control is a complex topic if it comes to the operating system.
     Again, the &pcidssa; requirement is quite fuzzy at this point and does not
     specifically state to which degree the restriction needs to be fulfilled.
     &productname; comes with all general Linux tools to limit and
     restrict access to certain system areas and components.
    </para>
    <para>
     Access can be controlled via specific users and groups of users. This
     are the traditional Unix permission settings. A more flexible mechanism
     for file systems are Access Control Lists (ACLs) that offer a more
     graduated approach. &selnx; can be used to separate the system to a
     maximum and to protect processes from gaining more resources and access
     then allowed.
    </para>
    <para>
     &selnx; and &aa; are not within the scope of this document. However, to
     protect critical systems that are likely to be targeted, research the
     security mechanisms. For more information about &selnx;, see
     <xref linkend="cha.selinux"/>.
    </para>
    <variablelist>
     <varlistentry>
      <term>
       7.1.2 Restrict access to privileged user IDs to least privileges
       necessary to perform job responsibilities.
      </term>
      <listitem>
       <para>
        The standard Unix permissions allow the setting of Read, Write and
        Execution flags for user and group IDs. A general group called
        <systemitem class="groupname">others</systemitem> or
        <systemitem class="groupname">world</systemitem> defines the access
        for users that do not fit into
        the first two groups. This allows a straightforward way to grant or
        deny access to file system resources.
       </para>
       <para>
        ACLs allow an extra level of restriction. It is possible to set
        read-write access for one user ID and only read access to a second
        one. The same goes for group IDs. The command-line tools are included
        inside the package <package>acl</package> and allow direct
        modification of file system resources<!--fixme wording-->.
       </para>
       <screen>getfacl /tmp/test.txt</screen>
       <screen>setfacl -m "u:dbuser:rw /tmp/test.txt</screen>
       <screen>getfacl /tmp/test.txt</screen>
       <para>
        Standard Unix permissions come also with a so called StickyBit. This
        allows the execution of certain programs with higher privileges then
        the user who is executing those programs. The best example for this
        is the <command>passwd</command> tool that needs to modify the
        <filename>/etc/shadow</filename> to
        change the user's password.
       </para>
       <para>
        In respect to the StickyBit Linux capabilities are also a way to
        explicitly allow certain operations or behaviors to binaries. An
        example for this is the command <command>ping</command> from the
        package <package>iputils</package>. It needs
        no StickyBit but needs to be able to send ICMP IP packets over the
        network card. For this it needs the <literal>CAP_NET_RAW</literal> capability that is
        Effective and Permitted (+ep)<!-- fixme: what is +ep, a permissions string? -->.
       </para>
       <screen>getcap /usr/bin/ping</screen>
       <screen>/usr/bin/ping = cap_net_raw+ep</screen>
       <para>
        Login access control to the system can be managed via the pluggable
        authentication module (PAM) mechanism. There are several modules
        directly available in &productname; that allow setups like
        control of the login time, multiple authentication mechanisms and
        central databases like NIS, LDAP or &ad;.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para/>
   </sect3>
   <sect3>
    <title>Requirement 8: <systemitem>Identify and authenticate access to system component</systemitem></title>
    <para>
     It is best practice to have a central database with user information and
     a unique identifier (UID) to grant or deny access to certain system
     components. This makes it easy to give administrators special access to
     group of servers or a database engineer permission to a certain DBMS
     system.
    </para>
    <para>
     On a stand-alone server unique identifiers are already managed via the
     standard Linux user and group IDs. These are listed inside
     <filename>/etc/passwd</filename> and <filename>/etc/group</filename>.
    </para>
    <variablelist>
     <varlistentry xml:id="vle.pcidss.disable-user">
      <term>
       8.1.4 Remove/disable inactive user accounts within 90 days.
      </term>
      <listitem>
      <para>
       In this context, There are many advantages to using a centralized
       infrastructure for user accounts like NIS, LDAP, or &ad;:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         It is easy to identify and automatically disable inactive accounts
        </para>
       </listitem>
       <listitem>
        <para>
         User accounts only need to be disabled in one place. After their
         access is revoked, the user cannot use any service that relies on
         the centralized account infrastructure.
        </para>
       </listitem>
      </itemizedlist>
      <para>
       However, if you are using local accounts, these can be checked for
       inactivity when a user is logging in. This module checks the last
       login time recorded in <filename>/var/log/lastlog</filename> and
       calculates the number of days since.
       By default, access is denied when the inactivity reaches 90 days.
      </para>
      <para>
       To list the local accounts last login time use the command
       <command>lastlog</command>.
      </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="vle.pcidss.lock-user">
      <term>
       8.1.6 Limit repeated access attempts by locking out the user ID after
       not more than six attempts.
      </term>
      <listitem>
       <para>
        As stated in <xref linkend="vle.pcidss.disable-user"/>, a centralized
        account infrastructure will have this capability. On the
        &productname; system, we can check and limit access attempts with the
        <systemitem>pam_tally2</systemitem> PAM module. The module is
        executed during login time and checks the recorded failed attempts
        since the last successful login. To check and reset the account
        status, use the tool <command>pam_tally2</command>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       8.1.7 Set the lockout duration to a minimum of 30 minutes or until an
       administrator enables the user ID.
      </term>
      <listitem>
      <para>
       The PAM module <systemitem>pam_tally2</systemitem> that was described
       for <xref linkend="vle.pcidss.lock-user"/> can be used to lock an
       account for a given time after a failed login attempt. The parameter
       <literal>unlock_time=1800</literal> must be configured into the PAM
       configuration. The default setting is that only the administrator can
       reactivate a locked account.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="vle.pcidss.multi-factor-local">
      <term>
       8.3.1 Incorporate multi-factor authentication for all non-console access
       into the CDE for personnel with administrative access.
      </term>
      <listitem>
       <para>
        To authenticate users for administrative access with multiple factors, use
        the pluggable authentication module (PAM) mechanism. This makes it
        flexible to add new methods to the authentication process and to
        adjust it if needed.<!--fixme wording-->
       </para>
       <para>
        Another way of multi-factor authentication for SSH connections is the
        additional usage of public keys. To connect to a system, it is
        necessary to prove that you are in the possession of the appropriate
        private key. When accepted you need to enter a password at the second
        stage. Thus, attackers need to acquire a private key before they can
        even try to brute force a password prompt.
       </para>
       <para>
        For commercial one-time password (OTP) products, there is usually
        also a Linux PAM module available.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="vle.pcidss.multi-factor-remote">
      <term>
       8.3.2 Incorporate multi-factor authentication for all remote network
       access (both user and administrator, and including third-party access
       for support or maintenance) originating from outside the entity’s
       network.
      </term>
      <listitem>
       <para>
        For details, see <xref linkend="vle.pcidss.multi-factor-local"/>.
        <!-- FIXME: structure: use two terms instead? -->
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Requirement 9: Restrict physical access to cardholder data</title>
    <para>
     Physical access to systems that are involved in processing cardholder
     data are not within the scope of general operating system security.
     Appropriate facility entry controls need to be in place to
     allow onside personnel employees and visitors to access systems directly.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>Regularly Monitor and Test Networks</title>
   <para/>
   <sect3>
    <title>Requirement 10: Track and monitor all access to network resources and cardholder data</title>
    <para>
     A major key point to track user activities is a synchronized time
     reference. This is done via the NTP protocol that allows servers to keep
     their local time in sync with a central system. The central NTP server
     inside the cardholder data environment (CDE) should not rely on
     external connections to the Internet to update the system time.
     Alternatively, system time can be updated using DCF77 radio
     transmissions or a GPS receiver.
    </para>
    <para>
     A synchronized time reference makes it easy to correlate events inside
     recorded log files. This can be general syslog entries collected by a
     central syslog<!-- fixme: formatting--> server or kernel audit messages
     by the daemon <systemitem class="daemon">audit</systemitem>.
    </para>
    <para>
     For information about auditing, see <xref linkend="part.audit"/>. All
     subsections inside this requirement relevant to auditing can be
     fulfilled by defining appropriate auditing rules that can be saved
     inside a central storage.
    </para>
   </sect3>
   <sect3>
    <title>Requirement 11: Regularly Test Security Systems and Processes</title>
    <para>
     Testing the discussed security mechanisms is also a key requirement for
     &pcidssa;. Evaluating the configurations and testing logging mechanisms
     can protect against know security risks and ensure that essential
     information are available to identify possible security breaches.
     Testing capabilities should be considered during system design already.
    </para>
    <para>
     To keep track of system integrity, &productname; comes with the Advanced
     Intrusion Detection Environment (AIDE). AIDE creates a hash value
     database of all relevant OS files. After initialization, it can be used
     to verify the integrity of all previously saved files. To employ AIDE,
     it is best to regularly create database snapshots and save them to a
     central system on which you can evaluate possible modifications.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>Maintain an Information Security Policy</title>
   <para/>
   <sect3>
    <title>Requirement 12: Maintain a Policy That Addresses Information Security for All Personnel</title>
    <para>
     Any organization that handles information worthy of protection should
     have general security policy. All relevant aspects should be
     included to make it clear for employees and stakeholders about possible
     risks and how to avoid them.
    </para>
    <para>
     A security policies should also be evaluated regularly and adjusted to
     keep the protection level as high as possible.
    </para>
   </sect3>
  </sect2>
 </sect1>
</appendix>
